#!/usr/bin/env python3

import time
import os
import subprocess
from datetime import datetime as dt, timedelta
import argparse
from pathlib import Path
import pickle
from dateutil import parser as dparser

# Config
notification_interval = timedelta(hours=2)
state_dir = Path(f"{os.path.expanduser('~')}/.jstate/notify-at")
wakeup_time_path = Path(f"{state_dir}/wakeup_time")
reflected_flag_path = Path(f"{state_dir}/reflected")
next_reflection = Path(f"{state_dir}/next_reflection")

state_dir.mkdir(parents=True, exist_ok=True)

# Args
parser = argparse.ArgumentParser()
parser.add_argument('--wakeup', action='store_true')
parser.add_argument('--set-wakeup')
parser.add_argument('--get-state', action='store_true')
parser.add_argument('--use-voice', action='store_true')
parser.add_argument('--loop', action='store_true')
parser.add_argument('--reflected', action='store_true')
args = parser.parse_args()

def format_time_delta(td, seconds=True):
    a,b,c = str(td).split(".")[0].split(':')
    if seconds:
        return f"{a.zfill(2)}:{b};{c}"
    else:
        return f"{a.zfill(2)}:{b}"

def main():
    # Setup first time trigger
    if not next_reflection.exists():
        with next_reflection.open('wb') as f:
            pickle.dump(dt.now(), f)

    with next_reflection.open('rb') as f:
        next_notification_time = pickle.load(f)

    #.replace(hour=0, minute=0, second=0, microsecond=0)
    #while next_notification_time <= dt.now(): # - notification_interval:
    #    next_notification_time += notification_interval

    if args.reflected:
        reflected_flag_path.touch(exist_ok=True)

    if args.wakeup or not wakeup_time_path.exists():
        wakeup_time = dt.now()
        with wakeup_time_path.open('wb') as f:
            pickle.dump(wakeup_time, f)

    if args.set_wakeup:
        wakeup_time = dparser.parse(args.set_wakeup)
        with wakeup_time_path.open('wb') as f:
            pickle.dump(wakeup_time, f)

    with wakeup_time_path.open('rb') as f:
        wakeup_time = pickle.load(f)

    bedtime = wakeup_time + timedelta(hours=12)

    def eod():
        return bedtime - dt.now()
    def j_time():
        return dt.now() - wakeup_time

    if args.get_state:
        print("         J-Time:", format_time_delta(j_time()))
        print("     End of Day:", format_time_delta(eod()))
        print("Next Reflection:", next_notification_time.strftime("%H:%M") + \
              "  NOW" if next_notification_time < dt.now()else "")
        print("         Wakeup:", wakeup_time.strftime("%H:%M  %a"))
        print("        Bedtime:", bedtime.strftime("%H:%M"))
    elif args.loop:
        while True:
            print(dt.now(), "<>", next_notification_time, end="\r")
            if next_notification_time <= dt.now():
                print("Time to reflect")
                while not reflected_flag_path.exists():
                    if args.use_voice:
                        subprocess.run(["say", "reflect now"])
                    subprocess.run(["terminal-notifier", 
                        "-title", "Reflect now",
                        "-message", f"It's {format_time_delta(j_time())} / {dt.now().strftime('%H:%M')}. EOD in \
                            {format_time_delta(eod(), False)} (at {bedtime.strftime('%H:%M')}).",
                        "-contentImage", "https://i.pinimg.com/originals/fc/60/62/fc60622ac3c047ba90d9adaba24325bd.jpg"])
                    time.sleep(5*60)
                reflected_flag_path.unlink()
                next_notification_time = dt.now() + notification_interval
                with next_reflection.open('w') as f:
                    pickle.dump(next_notification_time, f)
            time.sleep(1)

if __name__ == "__main__":
    main()